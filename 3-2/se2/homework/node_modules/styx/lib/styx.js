"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var ESTree = require("./estree");
var Parser = require("./parser/parser");
var dot_1 = require("./exporters/dot");
exports.exportAsDot = dot_1.exportAsDot;
var json_1 = require("./exporters/json");
exports.exportAsJson = json_1.exportAsJson;
var object_1 = require("./exporters/object");
exports.exportAsObject = object_1.exportAsObject;
__export(require("./flow"));
function parse(program, options) {
    if (!isObject(program) || !program.type) {
        throw Error("'program' must be an object with a 'type' property");
    }
    if (program.type !== ESTree.NodeType.Program) {
        throw Error("The node type '" + program.type + "' is not supported");
    }
    var normalizedOptions = normalizeParserOptions(options);
    return Parser.parse(program, normalizedOptions);
}
exports.parse = parse;
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function normalizeParserOptions(options) {
    var removeTransitNodes;
    var rewriteConstantConditionalEdges;
    if (typeof options === "undefined") {
        removeTransitNodes = true;
        rewriteConstantConditionalEdges = true;
    }
    else {
        var passes = options.passes;
        removeTransitNodes =
            passes === true || (passes && passes.removeTransitNodes);
        rewriteConstantConditionalEdges =
            passes === true || (passes && passes.rewriteConstantConditionalEdges);
    }
    return {
        passes: {
            removeTransitNodes: removeTransitNodes,
            rewriteConstantConditionalEdges: rewriteConstantConditionalEdges
        }
    };
}
