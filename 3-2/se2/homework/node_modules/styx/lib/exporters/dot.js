"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var flow_1 = require("../flow");
var arrayUtil_1 = require("../util/arrayUtil");
function exportAsDot(flowGraph, graphName) {
    return computeDotLines(flowGraph, graphName).join("\n");
}
exports.exportAsDot = exportAsDot;
function computeDotLines(flowGraph, graphName) {
    var entryAndExitNodeList = flowGraph.nodes
        .filter(isExitNode)
        .map(function (node) { return node.id; })
        .join(" ");
    var _a = arrayUtil_1.partition(flowGraph.edges, function (edge) { return edge.type === flow_1.EdgeType.Conditional; }), conditionalEdges = _a[0], unconditionalEdges = _a[1];
    var innerLines = [
        "node [shape = doublecircle] " + entryAndExitNodeList,
        "node [shape = circle]",
        "",
        "// Unconditional edges"
    ].concat(unconditionalEdges.map(formatEdge));
    if (conditionalEdges.length > 0) {
        innerLines.push.apply(innerLines, ["",
            "// Conditional edges",
            "edge [color = red, fontcolor = red]"].concat(conditionalEdges.map(formatEdge)));
    }
    var graphLines = [
        "digraph control_flow_graph {"
    ].concat(innerLines.map(indent), [
        "}"
    ]);
    if (graphName) {
        graphLines.unshift("// " + graphName);
    }
    return graphLines;
}
function isExitNode(node) {
    return node.type === flow_1.NodeType.ErrorExit || node.type === flow_1.NodeType.SuccessExit;
}
function indent(line) {
    return "    " + line;
}
function formatEdge(edge) {
    var from = edge.source.id;
    var to = edge.target.id;
    var escapedLabel = escapeDoubleQuotes(edge.label);
    var attributes = edge.label ? " [label = \" " + escapedLabel + "\"]" : "";
    return from + " -> " + to + attributes;
}
function escapeDoubleQuotes(value) {
    return value.replace(/"/g, '\\"');
}
