"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ESTree = require("../../estree");
function stringify(expression) {
    var _a;
    var stringifiers = (_a = {},
        _a[ESTree.NodeType.ArrayExpression] = stringifyArrayExpression,
        _a[ESTree.NodeType.AssignmentExpression] = stringifyAssignmentExpression,
        _a[ESTree.NodeType.BinaryExpression] = stringifyBinaryExpression,
        _a[ESTree.NodeType.CallExpression] = stringifyCallExpression,
        _a[ESTree.NodeType.ConditionalExpression] = stringifyConditionalExpression,
        _a[ESTree.NodeType.Identifier] = stringifyIdentifier,
        _a[ESTree.NodeType.Literal] = stringifyLiteral,
        _a[ESTree.NodeType.LogicalExpression] = stringifyLogicalExpression,
        _a[ESTree.NodeType.MemberExpression] = stringifyMemberExpression,
        _a[ESTree.NodeType.NewExpression] = stringifyNewExpression,
        _a[ESTree.NodeType.ObjectExpression] = stringifyObjectExpression,
        _a[ESTree.NodeType.SequenceExpression] = stringifySequenceExpression,
        _a[ESTree.NodeType.ThisExpression] = stringifyThisExpression,
        _a[ESTree.NodeType.UnaryExpression] = stringifyUnaryExpression,
        _a[ESTree.NodeType.UpdateExpression] = stringifyUpdateExpression,
        _a);
    var stringifier = stringifiers[expression.type];
    return stringifier ? stringifier(expression) : "<UNEXPECTED>";
}
exports.stringify = stringify;
function stringifyArrayExpression(arrayExpression) {
    var stringifiedElements = "";
    var isFirstElement = true;
    var previousElementWasNull = false;
    for (var _i = 0, _a = arrayExpression.elements; _i < _a.length; _i++) {
        var element = _a[_i];
        if (!isFirstElement && !previousElementWasNull) {
            stringifiedElements += ",";
        }
        if (element === null) {
            stringifiedElements += ",";
            previousElementWasNull = true;
        }
        else {
            stringifiedElements += stringify(element);
            previousElementWasNull = false;
        }
        isFirstElement = false;
    }
    return "[" + stringifiedElements + "]";
}
function stringifyAssignmentExpression(assignmentExpression) {
    var left = stringify(assignmentExpression.left);
    var right = stringify(assignmentExpression.right);
    return left + " " + assignmentExpression.operator + " " + right;
}
function stringifyBinaryExpression(binaryExpression) {
    var left = stringify(binaryExpression.left);
    var right = stringify(binaryExpression.right);
    if (needsParenthesizing(binaryExpression.left)) {
        left = parenthesize(left);
    }
    if (needsParenthesizing(binaryExpression.right)) {
        right = parenthesize(right);
    }
    return left + " " + binaryExpression.operator + " " + right;
}
function stringifyCallExpression(callExpression) {
    var callee = stringify(callExpression.callee);
    var args = callExpression.arguments.map(function (arg) { return stringify(arg); }).join(", ");
    return callee + "(" + args + ")";
}
function stringifyConditionalExpression(conditionalExpression) {
    var test = stringify(conditionalExpression.test);
    var consequent = stringify(conditionalExpression.consequent);
    var alternate = stringify(conditionalExpression.alternate);
    if (needsParenthesizing(conditionalExpression.consequent)) {
        consequent = parenthesize(consequent);
    }
    if (needsParenthesizing(conditionalExpression.alternate)) {
        alternate = parenthesize(alternate);
    }
    return test + " ? " + consequent + " : " + alternate;
}
function stringifyIdentifier(identifier) {
    return identifier.name;
}
function stringifyLiteral(literal) {
    return literal.raw;
}
function stringifyLogicalExpression(logicalExpression) {
    var left = stringify(logicalExpression.left);
    var right = stringify(logicalExpression.right);
    if (needsParenthesizing(logicalExpression.left)) {
        left = parenthesize(left);
    }
    if (needsParenthesizing(logicalExpression.right)) {
        right = parenthesize(right);
    }
    return left + " " + logicalExpression.operator + " " + right;
}
function stringifyMemberExpression(memberExpression) {
    var object = stringify(memberExpression.object);
    var property = stringify(memberExpression.property);
    var left = needsParenthesizing(memberExpression.object)
        ? parenthesize(object)
        : object;
    return memberExpression.computed
        ? left + "[" + property + "]"
        : left + "." + property;
}
function stringifyNewExpression(newExpression) {
    var call = stringifyCallExpression(newExpression);
    return "new " + call;
}
function stringifyObjectExpression(objectExpression) {
    if (objectExpression.properties.length === 0) {
        return "{}";
    }
    var properties = objectExpression.properties
        .map(function (property) {
        var key = stringify(property.key);
        var value = stringify(property.value);
        return key + ": " + value;
    })
        .join(",\n    ");
    return "{\n    " + properties + "\n}";
}
function stringifySequenceExpression(sequenceExpression) {
    var expressions = sequenceExpression.expressions.map(stringify).join(", ");
    return parenthesize(expressions);
}
function stringifyThisExpression(thisExpression) {
    return "this";
}
function stringifyUnaryExpression(unaryExpression) {
    var operator = unaryExpression.operator;
    var argument = stringify(unaryExpression.argument);
    var joiner = operator.length > 1 ? " " : "";
    if (needsParenthesizing(unaryExpression.argument)) {
        argument = parenthesize(argument);
    }
    return unaryExpression.prefix
        ? operator + joiner + argument
        : argument + joiner + operator;
}
function stringifyUpdateExpression(updateExpression) {
    return updateExpression.prefix
        ? updateExpression.operator + stringify(updateExpression.argument)
        : stringify(updateExpression.argument) + updateExpression.operator;
}
function needsParenthesizing(expression) {
    switch (expression.type) {
        case ESTree.NodeType.AssignmentExpression:
        case ESTree.NodeType.BinaryExpression:
        case ESTree.NodeType.ConditionalExpression:
        case ESTree.NodeType.LogicalExpression:
            return true;
        default:
            return false;
    }
}
function parenthesize(value) {
    return "(" + value + ")";
}
