"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var flow_1 = require("../../flow");
function parseBreakStatement(breakStatement, currentNode, context) {
    var enclosingStatement = findLabeledEnclosingStatement(context, breakStatement.label);
    var finalizerCompletion = runFinalizersBeforeBreakOrContinue(currentNode, context, enclosingStatement);
    if (!finalizerCompletion.normal) {
        return finalizerCompletion;
    }
    enclosingStatement.breakTarget.appendTo(finalizerCompletion.normal, "break", breakStatement, flow_1.EdgeType.AbruptCompletion);
    return { break: true };
}
exports.parseBreakStatement = parseBreakStatement;
function parseContinueStatement(continueStatement, currentNode, context) {
    var enclosingStatement = findLabeledEnclosingStatement(context, continueStatement.label);
    if (enclosingStatement.continueTarget === null) {
        throw new Error("Illegal continue target detected: \"" + continueStatement.label + "\" does not label an enclosing iteration statement");
    }
    var finalizerCompletion = runFinalizersBeforeBreakOrContinue(currentNode, context, enclosingStatement);
    if (!finalizerCompletion.normal) {
        return finalizerCompletion;
    }
    enclosingStatement.continueTarget.appendTo(finalizerCompletion.normal, "continue", continueStatement, flow_1.EdgeType.AbruptCompletion);
    return { continue: true };
}
exports.parseContinueStatement = parseContinueStatement;
function findLabeledEnclosingStatement(context, label) {
    return context.enclosingStatements.find(function (statement) {
        if (label) {
            // If we have a truthy label, we look for a matching enclosing statement
            return statement.label === label.name;
        }
        // If we don't have a label, we look for the topmost enclosing statement
        // that is not a try statement because that would be an invalid target
        // for `break` or `continue` statements
        return statement.type !== 0 /* TryStatement */;
    });
}
function runFinalizersBeforeBreakOrContinue(currentNode, context, target) {
    var enclosingStatements = context.enclosingStatements.enumerateElements();
    for (var _i = 0, enclosingStatements_1 = enclosingStatements; _i < enclosingStatements_1.length; _i++) {
        var statement = enclosingStatements_1[_i];
        if (statement.type === 0 /* TryStatement */) {
            var tryStatement = statement;
            if (tryStatement.parseFinalizer && !tryStatement.isCurrentlyInFinalizer) {
                tryStatement.isCurrentlyInFinalizer = true;
                var finalizer = tryStatement.parseFinalizer();
                tryStatement.isCurrentlyInFinalizer = false;
                finalizer.bodyEntry.appendEpsilonEdgeTo(currentNode);
                if (finalizer.bodyCompletion.normal) {
                    currentNode = finalizer.bodyCompletion.normal;
                }
                else {
                    return finalizer.bodyCompletion;
                }
            }
        }
        if (statement === target) {
            // We only run finalizers of `try` statements that are nested
            // within the target enclosing statement. Therefore, stop here.
            break;
        }
    }
    return { normal: currentNode };
}
