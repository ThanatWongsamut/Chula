"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var stringifier_1 = require("../expressions/stringifier");
var estreeFactory_1 = require("../../estreeFactory");
var flow_1 = require("../../flow");
function parseThrowStatement(throwStatement, currentNode, context) {
    var throwLabel = "throw " + stringifier_1.stringify(throwStatement.argument);
    var enclosingStatements = context.enclosingStatements.enumerateElements();
    var foundHandler = false;
    for (var _i = 0, enclosingStatements_1 = enclosingStatements; _i < enclosingStatements_1.length; _i++) {
        var statement = enclosingStatements_1[_i];
        if (statement.type !== 0 /* TryStatement */) {
            continue;
        }
        var tryStatement = statement;
        if (tryStatement.handler && tryStatement.isCurrentlyInTryBlock) {
            var handlerVariableAssignment = estreeFactory_1.createAssignmentExpression({
                left: tryStatement.handler.param,
                right: throwStatement.argument
            });
            var assignmentNode = context
                .createNode()
                .appendTo(currentNode, stringifier_1.stringify(handlerVariableAssignment), handlerVariableAssignment);
            tryStatement.handlerBodyEntry.appendEpsilonEdgeTo(assignmentNode);
            foundHandler = true;
            break;
        }
        else if (tryStatement.parseFinalizer &&
            !tryStatement.isCurrentlyInFinalizer) {
            tryStatement.isCurrentlyInFinalizer = true;
            var finalizer = tryStatement.parseFinalizer();
            tryStatement.isCurrentlyInFinalizer = false;
            finalizer.bodyEntry.appendEpsilonEdgeTo(currentNode);
            if (finalizer.bodyCompletion.normal) {
                currentNode = finalizer.bodyCompletion.normal;
            }
            else {
                return finalizer.bodyCompletion;
            }
        }
    }
    if (!foundHandler) {
        context.currentFlowGraph.errorExit.appendTo(currentNode, throwLabel, throwStatement, flow_1.EdgeType.AbruptCompletion);
    }
    return { throw: true };
}
exports.parseThrowStatement = parseThrowStatement;
