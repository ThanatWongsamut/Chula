"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var function_1 = require("../declarations/function");
var variable_1 = require("../declarations/variable");
var block_1 = require("./block");
var breakContinue_1 = require("./breakContinue");
var debugger_1 = require("./debugger");
var doWhile_1 = require("./doWhile");
var empty_1 = require("./empty");
var expression_1 = require("./expression");
var for_1 = require("./for");
var forIn_1 = require("./forIn");
var if_1 = require("./if");
var labeled_1 = require("./labeled");
var return_1 = require("./return");
var switch_1 = require("./switch");
var throw_1 = require("./throw");
var try_1 = require("./try");
var while_1 = require("./while");
var with_1 = require("./with");
var ESTree = require("../../estree");
function parseStatements(statements, currentNode, context) {
    for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
        var statement = statements_1[_i];
        var completion = parseStatement(statement, currentNode, context);
        if (!completion.normal) {
            // If we encounter an abrupt completion, normal control flow is interrupted
            // and the following statements aren't executed
            return completion;
        }
        currentNode = completion.normal;
    }
    return { normal: currentNode };
}
exports.parseStatements = parseStatements;
function parseStatement(statement, currentNode, context) {
    var _a;
    var statementParsers = (_a = {},
        _a[ESTree.NodeType.BlockStatement] = block_1.parseBlockStatement,
        _a[ESTree.NodeType.BreakStatement] = breakContinue_1.parseBreakStatement,
        _a[ESTree.NodeType.ContinueStatement] = breakContinue_1.parseContinueStatement,
        _a[ESTree.NodeType.DebuggerStatement] = debugger_1.parseDebuggerStatement,
        _a[ESTree.NodeType.DoWhileStatement] = doWhile_1.parseDoWhileStatement,
        _a[ESTree.NodeType.EmptyStatement] = empty_1.parseEmptyStatement,
        _a[ESTree.NodeType.ExpressionStatement] = expression_1.parseExpressionStatement,
        _a[ESTree.NodeType.ForInStatement] = forIn_1.parseForInStatement,
        _a[ESTree.NodeType.ForStatement] = for_1.parseForStatement,
        _a[ESTree.NodeType.FunctionDeclaration] = function_1.parseFunctionDeclaration,
        _a[ESTree.NodeType.IfStatement] = if_1.parseIfStatement,
        _a[ESTree.NodeType.LabeledStatement] = labeled_1.parseLabeledStatement,
        _a[ESTree.NodeType.ReturnStatement] = return_1.parseReturnStatement,
        _a[ESTree.NodeType.SwitchStatement] = switch_1.parseSwitchStatement,
        _a[ESTree.NodeType.ThrowStatement] = throw_1.parseThrowStatement,
        _a[ESTree.NodeType.TryStatement] = try_1.parseTryStatement,
        _a[ESTree.NodeType.VariableDeclaration] = variable_1.parseVariableDeclaration,
        _a[ESTree.NodeType.WhileStatement] = while_1.parseWhileStatement,
        _a[ESTree.NodeType.WithStatement] = with_1.parseWithStatement,
        _a);
    var parsingMethod = statementParsers[statement.type];
    if (!parsingMethod) {
        throw Error("Encountered unsupported statement type \"" + statement.type + "\"");
    }
    return parsingMethod(statement, currentNode, context);
}
exports.parseStatement = parseStatement;
