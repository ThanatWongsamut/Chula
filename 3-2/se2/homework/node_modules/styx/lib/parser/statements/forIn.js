"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var negator_1 = require("../expressions/negator");
var stringifier_1 = require("../expressions/stringifier");
var statement_1 = require("./statement");
var ESTree = require("../../estree");
var estreeFactory_1 = require("../../estreeFactory");
function parseForInStatement(forInStatement, currentNode, context, label) {
    var iteratorFunctionIdentifier = estreeFactory_1.createIdentifier("$$iterator");
    var iteratorCall = estreeFactory_1.createCallExpression(iteratorFunctionIdentifier, [
        forInStatement.right
    ]);
    var iteratorName = context.createTemporaryLocalVariableName("iter");
    var iteratorIdentifier = estreeFactory_1.createIdentifier(iteratorName);
    var iteratorAssignment = estreeFactory_1.createAssignmentExpression({
        left: iteratorIdentifier,
        right: iteratorCall
    });
    var conditionNode = context
        .createNode()
        .appendTo(currentNode, stringifier_1.stringify(iteratorAssignment), iteratorAssignment);
    var isDoneExpression = {
        type: ESTree.NodeType.MemberExpression,
        computed: false,
        object: iteratorIdentifier,
        property: estreeFactory_1.createIdentifier("done")
    };
    var isNotDoneExpression = negator_1.negateTruthiness(isDoneExpression);
    var startOfLoopBody = context
        .createNode()
        .appendConditionallyTo(conditionNode, stringifier_1.stringify(isNotDoneExpression), isNotDoneExpression);
    var finalNode = context
        .createNode()
        .appendConditionallyTo(conditionNode, stringifier_1.stringify(isDoneExpression), isDoneExpression);
    var nextElementCallee = {
        type: ESTree.NodeType.MemberExpression,
        computed: false,
        object: iteratorIdentifier,
        property: estreeFactory_1.createIdentifier("next")
    };
    var propertyAssignment = estreeFactory_1.createAssignmentExpression({
        left: getLeftHandSideOfAssignment(forInStatement),
        right: estreeFactory_1.createCallExpression(nextElementCallee)
    });
    var propertyAssignmentNode = context
        .createNode()
        .appendTo(startOfLoopBody, stringifier_1.stringify(propertyAssignment), propertyAssignment);
    context.enclosingStatements.push({
        type: 1 /* OtherStatement */,
        breakTarget: finalNode,
        continueTarget: conditionNode,
        label: label
    });
    var loopBodyCompletion = statement_1.parseStatement(forInStatement.body, propertyAssignmentNode, context);
    context.enclosingStatements.pop();
    if (loopBodyCompletion.normal) {
        conditionNode.appendEpsilonEdgeTo(loopBodyCompletion.normal);
    }
    return { normal: finalNode };
}
exports.parseForInStatement = parseForInStatement;
function getLeftHandSideOfAssignment(forInStatement) {
    if (forInStatement.left.type === ESTree.NodeType.VariableDeclaration) {
        var variableDeclarator = forInStatement.left
            .declarations[0];
        var variableName = variableDeclarator.id.name;
        return estreeFactory_1.createIdentifier(variableName);
    }
    return forInStatement.left;
}
