"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var stringifier_1 = require("../expressions/stringifier");
var flow_1 = require("../../flow");
function parseReturnStatement(returnStatement, currentNode, context) {
    var argument = returnStatement.argument
        ? stringifier_1.stringify(returnStatement.argument)
        : "undefined";
    var returnLabel = "return " + argument;
    var finalizerCompletion = runFinalizersBeforeReturn(currentNode, context);
    if (!finalizerCompletion.normal) {
        return finalizerCompletion;
    }
    context.currentFlowGraph.successExit.appendTo(finalizerCompletion.normal, returnLabel, returnStatement, flow_1.EdgeType.AbruptCompletion);
    return { return: true };
}
exports.parseReturnStatement = parseReturnStatement;
function runFinalizersBeforeReturn(currentNode, context) {
    var enclosingTryStatements = (context.enclosingStatements
        .enumerateElements()
        .filter(function (statement) { return statement.type === 0 /* TryStatement */; }));
    for (var _i = 0, enclosingTryStatements_1 = enclosingTryStatements; _i < enclosingTryStatements_1.length; _i++) {
        var tryStatement = enclosingTryStatements_1[_i];
        if (tryStatement.parseFinalizer && !tryStatement.isCurrentlyInFinalizer) {
            tryStatement.isCurrentlyInFinalizer = true;
            var finalizer = tryStatement.parseFinalizer();
            tryStatement.isCurrentlyInFinalizer = false;
            finalizer.bodyEntry.appendEpsilonEdgeTo(currentNode);
            if (finalizer.bodyCompletion.normal) {
                currentNode = finalizer.bodyCompletion.normal;
            }
            else {
                return finalizer.bodyCompletion;
            }
        }
    }
    return { normal: currentNode };
}
