"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var variable_1 = require("../declarations/variable");
var negator_1 = require("../expressions/negator");
var stringifier_1 = require("../expressions/stringifier");
var expression_1 = require("./expression");
var statement_1 = require("./statement");
var ESTree = require("../../estree");
function parseForStatement(forStatement, currentNode, context, label) {
    var testDecisionNode = parseInit(forStatement.init, currentNode, context)
        .normal;
    // Create nodes for loop cornerstones
    var beginOfLoopBodyNode = context.createNode();
    var updateNode = context.createNode();
    var finalNode = context.createNode();
    if (forStatement.test) {
        // If the loop has a test expression,
        // we need to add truthy and falsy edges
        var truthyCondition = forStatement.test;
        var falsyCondition = negator_1.negateTruthiness(truthyCondition);
        // Create edges labels
        var truthyConditionLabel = stringifier_1.stringify(truthyCondition);
        var falsyConditionLabel = stringifier_1.stringify(falsyCondition);
        // Add truthy and falsy edges
        beginOfLoopBodyNode.appendConditionallyTo(testDecisionNode, truthyConditionLabel, truthyCondition);
        finalNode.appendConditionallyTo(testDecisionNode, falsyConditionLabel, falsyCondition);
    }
    else {
        // If the loop doesn't have a test expression,
        // the loop body starts unconditionally after the initialization
        beginOfLoopBodyNode.appendEpsilonEdgeTo(testDecisionNode);
    }
    context.enclosingStatements.push({
        type: 1 /* OtherStatement */,
        continueTarget: updateNode,
        breakTarget: finalNode,
        label: label
    });
    var loopBodyCompletion = statement_1.parseStatement(forStatement.body, beginOfLoopBodyNode, context);
    context.enclosingStatements.pop();
    if (forStatement.update) {
        // If the loop has an update expression,
        // parse it and append it to the end of the loop body
        var endOfUpdateNode = expression_1.parseExpression(forStatement.update, updateNode, context);
        testDecisionNode.appendEpsilonEdgeTo(endOfUpdateNode);
    }
    else {
        // If the loop doesn't have an update expression,
        // treat the update node as a dummy and point it to the test node
        testDecisionNode.appendEpsilonEdgeTo(updateNode);
    }
    if (loopBodyCompletion.normal) {
        // If we reached the end of the loop body through normal control flow,
        // continue regularly with the update
        updateNode.appendEpsilonEdgeTo(loopBodyCompletion.normal);
    }
    return { normal: finalNode };
}
exports.parseForStatement = parseForStatement;
function parseInit(init, currentNode, context) {
    if (init === null) {
        return { normal: currentNode };
    }
    if (init.type === ESTree.NodeType.VariableDeclaration) {
        return variable_1.parseVariableDeclaration(init, currentNode, context);
    }
    return {
        normal: expression_1.parseExpression(init, currentNode, context)
    };
}
