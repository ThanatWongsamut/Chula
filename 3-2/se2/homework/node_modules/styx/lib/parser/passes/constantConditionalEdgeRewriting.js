"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ESTree = require("../../estree");
var numericSet_1 = require("../../collections/numericSet");
var ArrayUtils = require("../../util/arrayUtil");
var flow_1 = require("../../flow");
function rewriteConstantConditionalEdges(graph) {
    var visitedNodes = numericSet_1.NumericSet.create();
    var edgesToRemove = [];
    visitNode(graph.entry, visitedNodes, edgesToRemove);
    for (var _i = 0, edgesToRemove_1 = edgesToRemove; _i < edgesToRemove_1.length; _i++) {
        var edge = edgesToRemove_1[_i];
        removeEdge(edge);
    }
}
exports.rewriteConstantConditionalEdges = rewriteConstantConditionalEdges;
function visitNode(node, visitedNodes, edgesToRemove) {
    if (visitedNodes.contains(node.id)) {
        return;
    }
    visitedNodes.add(node.id);
    for (var _i = 0, _a = node.outgoingEdges; _i < _a.length; _i++) {
        var edge = _a[_i];
        inspectEdge(edge, edgesToRemove);
        visitNode(edge.target, visitedNodes, edgesToRemove);
    }
}
function inspectEdge(edge, edgesToRemove) {
    if (edge.type !== flow_1.EdgeType.Conditional ||
        edge.data == null ||
        !isCompileTimeConstant(edge.data)) {
        // We only deal with conditional edges that have a condition
        // whose truthiness we can safely determine at compile-time
        return;
    }
    if (isAlwaysTruthy(edge.data)) {
        // Conditional edges with a constant truthy test are always taken;
        // we can therefore turn them into simple epsilon edges
        turnEdgeIntoEpsilonEdge(edge);
    }
    else {
        // Conditional edges with a constant falsy test are never taken;
        // we thus remove this edge after walking the entire graph
        edgesToRemove.push(edge);
    }
}
function isCompileTimeConstant(expression) {
    switch (expression.type) {
        case ESTree.NodeType.Literal:
            return true;
        case ESTree.NodeType.UnaryExpression:
            var unaryExpression = expression;
            return (unaryExpression.operator === "!" &&
                isCompileTimeConstant(unaryExpression.argument));
        default:
            return false;
    }
}
function isAlwaysTruthy(expression) {
    switch (expression.type) {
        case ESTree.NodeType.Literal:
            return !!expression.value;
        case ESTree.NodeType.UnaryExpression:
            var unaryExpression = expression;
            if (unaryExpression.operator !== "!") {
                throw Error("This branch shouldn't have been reached");
            }
            return !isAlwaysTruthy(unaryExpression.argument);
        default:
            throw Error("This case shouldn't have been reached");
    }
}
function turnEdgeIntoEpsilonEdge(edge) {
    edge.type = flow_1.EdgeType.Epsilon;
    edge.label = "";
    edge.data = null;
}
function removeEdge(edge) {
    ArrayUtils.removeElementFromArray(edge, edge.source.outgoingEdges);
    ArrayUtils.removeElementFromArray(edge, edge.target.incomingEdges);
}
